@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="chart-container" role="img" aria-label="@GetAccessibleDescription()">
    <canvas id="@ChartId" aria-hidden="true"></canvas>
    
    <!-- Screen reader accessible data table -->
    <div class="sr-only">
        <h4>Pie Chart Data</h4>
        @if (Labels.Any() && Data.Any())
        {
            <table>
                <caption>Distribution breakdown</caption>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Value</th>
                        <th>Percentage</th>
                    </tr>
                </thead>
                <tbody>
                    @{
                        var total = Data.Sum();
                    }
                    @for (int i = 0; i < Labels.Length && i < Data.Length; i++)
                    {
                        var percentage = total > 0 ? (Data[i] / total * 100) : 0;
                        <tr>
                            <td>@Labels[i]</td>
                            <td>@Data[i].ToString("C")</td>
                            <td>@percentage.ToString("N1")%</td>
                        </tr>
                    }
                </tbody>
                <tfoot>
                    <tr>
                        <td><strong>Total</strong></td>
                        <td><strong>@total.ToString("C")</strong></td>
                        <td><strong>100%</strong></td>
                    </tr>
                </tfoot>
            </table>
        }
    </div>
</div>

@code {
    [Parameter] public string ChartId { get; set; } = $"pieChart_{Guid.NewGuid():N}";
    [Parameter] public string[] Labels { get; set; } = Array.Empty<string>();
    [Parameter] public decimal[] Data { get; set; } = Array.Empty<decimal>();
    [Parameter] public string[]? Colors { get; set; }
    [Parameter] public bool ShowLegend { get; set; } = true;
    [Parameter] public string LegendPosition { get; set; } = "right";

    private bool isRendered = false;

    private static readonly string[] DefaultColors = new[]
    {
        "#C41E3A", "#28a745", "#ffc107", "#17a2b8",
        "#6c757d", "#e83e8c", "#fd7e14", "#6610f2",
        "#20c997", "#343a40", "#007bff", "#dc3545"
    };

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || !isRendered)
        {
            try
            {
                await RenderChart();
                isRendered = true;
            }
            catch (Microsoft.JSInterop.JSException) { }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (isRendered && Labels.Any() && Data.Any())
        {
            try
            {
                await RenderChart();
            }
            catch (Microsoft.JSInterop.JSException) { }
        }
    }

    private async Task RenderChart()
    {
        if (!Labels.Any() || !Data.Any()) return;

        var colors = Colors ?? DefaultColors.Take(Labels.Length).ToArray();

        await JS.InvokeVoidAsync("chartInterop.createPieChart", ChartId, Labels, Data, colors, new
        {
            plugins = new
            {
                legend = new
                {
                    position = LegendPosition,
                    display = ShowLegend
                }
            }
        });
    }

    private string GetAccessibleDescription()
    {
        if (!Labels.Any() || !Data.Any())
            return "Pie chart with no data";
        
        var total = Data.Sum();
        var topItems = Labels.Zip(Data, (label, value) => new { label, value })
            .OrderByDescending(x => x.value)
            .Take(3)
            .Select(x => $"{x.label} ({(total > 0 ? x.value / total * 100 : 0):N0}%)");
        
        return $"Pie chart showing {Labels.Length} categories. Largest: {string.Join(", ", topItems)}. Total: {total:C2}";
    }

    public async Task UpdateData(string[] labels, decimal[] data, string[]? colors = null)
    {
        Labels = labels;
        Data = data;
        Colors = colors;
        await RenderChart();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            await JS.InvokeVoidAsync("chartInterop.destroyChart", ChartId);
        }
        catch (Microsoft.JSInterop.JSException) { }
    }
}
